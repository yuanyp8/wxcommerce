// Code generated by Kitex v0.9.0. DO NOT EDIT.

package commentservice

import (
	"context"
	"errors"
	client "github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	streaming "github.com/cloudwego/kitex/pkg/streaming"
	comment "github.com/yuanyp8/wxcommerce/shared/kitex_gen/pms/comment"
	proto "google.golang.org/protobuf/proto"
)

var errInvalidMessageType = errors.New("invalid message type for service method handler")

var serviceMethods = map[string]kitex.MethodInfo{
	"CommentAdd": kitex.NewMethodInfo(
		commentAddHandler,
		newCommentAddArgs,
		newCommentAddResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"CommentList": kitex.NewMethodInfo(
		commentListHandler,
		newCommentListArgs,
		newCommentListResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"CommentUpdate": kitex.NewMethodInfo(
		commentUpdateHandler,
		newCommentUpdateArgs,
		newCommentUpdateResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"CommentDelete": kitex.NewMethodInfo(
		commentDeleteHandler,
		newCommentDeleteArgs,
		newCommentDeleteResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
}

var (
	commentServiceServiceInfo                = NewServiceInfo()
	commentServiceServiceInfoForClient       = NewServiceInfoForClient()
	commentServiceServiceInfoForStreamClient = NewServiceInfoForStreamClient()
)

// for server
func serviceInfo() *kitex.ServiceInfo {
	return commentServiceServiceInfo
}

// for client
func serviceInfoForStreamClient() *kitex.ServiceInfo {
	return commentServiceServiceInfoForStreamClient
}

// for stream client
func serviceInfoForClient() *kitex.ServiceInfo {
	return commentServiceServiceInfoForClient
}

// NewServiceInfo creates a new ServiceInfo containing all methods
func NewServiceInfo() *kitex.ServiceInfo {
	return newServiceInfo(false, true, true)
}

// NewServiceInfo creates a new ServiceInfo containing non-streaming methods
func NewServiceInfoForClient() *kitex.ServiceInfo {
	return newServiceInfo(false, false, true)
}
func NewServiceInfoForStreamClient() *kitex.ServiceInfo {
	return newServiceInfo(true, true, false)
}

func newServiceInfo(hasStreaming bool, keepStreamingMethods bool, keepNonStreamingMethods bool) *kitex.ServiceInfo {
	serviceName := "CommentService"
	handlerType := (*comment.CommentService)(nil)
	methods := map[string]kitex.MethodInfo{}
	for name, m := range serviceMethods {
		if m.IsStreaming() && !keepStreamingMethods {
			continue
		}
		if !m.IsStreaming() && !keepNonStreamingMethods {
			continue
		}
		methods[name] = m
	}
	extra := map[string]interface{}{
		"PackageName": "pms",
	}
	if hasStreaming {
		extra["streaming"] = hasStreaming
	}
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.9.0",
		Extra:           extra,
	}
	return svcInfo
}

func commentAddHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(comment.CommentAddReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(comment.CommentService).CommentAdd(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *CommentAddArgs:
		success, err := handler.(comment.CommentService).CommentAdd(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CommentAddResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newCommentAddArgs() interface{} {
	return &CommentAddArgs{}
}

func newCommentAddResult() interface{} {
	return &CommentAddResult{}
}

type CommentAddArgs struct {
	Req *comment.CommentAddReq
}

func (p *CommentAddArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(comment.CommentAddReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *CommentAddArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *CommentAddArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *CommentAddArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *CommentAddArgs) Unmarshal(in []byte) error {
	msg := new(comment.CommentAddReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CommentAddArgs_Req_DEFAULT *comment.CommentAddReq

func (p *CommentAddArgs) GetReq() *comment.CommentAddReq {
	if !p.IsSetReq() {
		return CommentAddArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CommentAddArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CommentAddArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CommentAddResult struct {
	Success *comment.CommentAddResp
}

var CommentAddResult_Success_DEFAULT *comment.CommentAddResp

func (p *CommentAddResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(comment.CommentAddResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *CommentAddResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *CommentAddResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *CommentAddResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *CommentAddResult) Unmarshal(in []byte) error {
	msg := new(comment.CommentAddResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CommentAddResult) GetSuccess() *comment.CommentAddResp {
	if !p.IsSetSuccess() {
		return CommentAddResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CommentAddResult) SetSuccess(x interface{}) {
	p.Success = x.(*comment.CommentAddResp)
}

func (p *CommentAddResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CommentAddResult) GetResult() interface{} {
	return p.Success
}

func commentListHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(comment.CommentListReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(comment.CommentService).CommentList(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *CommentListArgs:
		success, err := handler.(comment.CommentService).CommentList(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CommentListResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newCommentListArgs() interface{} {
	return &CommentListArgs{}
}

func newCommentListResult() interface{} {
	return &CommentListResult{}
}

type CommentListArgs struct {
	Req *comment.CommentListReq
}

func (p *CommentListArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(comment.CommentListReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *CommentListArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *CommentListArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *CommentListArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *CommentListArgs) Unmarshal(in []byte) error {
	msg := new(comment.CommentListReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CommentListArgs_Req_DEFAULT *comment.CommentListReq

func (p *CommentListArgs) GetReq() *comment.CommentListReq {
	if !p.IsSetReq() {
		return CommentListArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CommentListArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CommentListArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CommentListResult struct {
	Success *comment.CommentListResp
}

var CommentListResult_Success_DEFAULT *comment.CommentListResp

func (p *CommentListResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(comment.CommentListResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *CommentListResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *CommentListResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *CommentListResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *CommentListResult) Unmarshal(in []byte) error {
	msg := new(comment.CommentListResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CommentListResult) GetSuccess() *comment.CommentListResp {
	if !p.IsSetSuccess() {
		return CommentListResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CommentListResult) SetSuccess(x interface{}) {
	p.Success = x.(*comment.CommentListResp)
}

func (p *CommentListResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CommentListResult) GetResult() interface{} {
	return p.Success
}

func commentUpdateHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(comment.CommentUpdateReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(comment.CommentService).CommentUpdate(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *CommentUpdateArgs:
		success, err := handler.(comment.CommentService).CommentUpdate(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CommentUpdateResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newCommentUpdateArgs() interface{} {
	return &CommentUpdateArgs{}
}

func newCommentUpdateResult() interface{} {
	return &CommentUpdateResult{}
}

type CommentUpdateArgs struct {
	Req *comment.CommentUpdateReq
}

func (p *CommentUpdateArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(comment.CommentUpdateReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *CommentUpdateArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *CommentUpdateArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *CommentUpdateArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *CommentUpdateArgs) Unmarshal(in []byte) error {
	msg := new(comment.CommentUpdateReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CommentUpdateArgs_Req_DEFAULT *comment.CommentUpdateReq

func (p *CommentUpdateArgs) GetReq() *comment.CommentUpdateReq {
	if !p.IsSetReq() {
		return CommentUpdateArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CommentUpdateArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CommentUpdateArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CommentUpdateResult struct {
	Success *comment.CommentUpdateResp
}

var CommentUpdateResult_Success_DEFAULT *comment.CommentUpdateResp

func (p *CommentUpdateResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(comment.CommentUpdateResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *CommentUpdateResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *CommentUpdateResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *CommentUpdateResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *CommentUpdateResult) Unmarshal(in []byte) error {
	msg := new(comment.CommentUpdateResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CommentUpdateResult) GetSuccess() *comment.CommentUpdateResp {
	if !p.IsSetSuccess() {
		return CommentUpdateResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CommentUpdateResult) SetSuccess(x interface{}) {
	p.Success = x.(*comment.CommentUpdateResp)
}

func (p *CommentUpdateResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CommentUpdateResult) GetResult() interface{} {
	return p.Success
}

func commentDeleteHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(comment.CommentDeleteReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(comment.CommentService).CommentDelete(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *CommentDeleteArgs:
		success, err := handler.(comment.CommentService).CommentDelete(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CommentDeleteResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newCommentDeleteArgs() interface{} {
	return &CommentDeleteArgs{}
}

func newCommentDeleteResult() interface{} {
	return &CommentDeleteResult{}
}

type CommentDeleteArgs struct {
	Req *comment.CommentDeleteReq
}

func (p *CommentDeleteArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(comment.CommentDeleteReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *CommentDeleteArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *CommentDeleteArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *CommentDeleteArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *CommentDeleteArgs) Unmarshal(in []byte) error {
	msg := new(comment.CommentDeleteReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CommentDeleteArgs_Req_DEFAULT *comment.CommentDeleteReq

func (p *CommentDeleteArgs) GetReq() *comment.CommentDeleteReq {
	if !p.IsSetReq() {
		return CommentDeleteArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CommentDeleteArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CommentDeleteArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CommentDeleteResult struct {
	Success *comment.CommentDeleteResp
}

var CommentDeleteResult_Success_DEFAULT *comment.CommentDeleteResp

func (p *CommentDeleteResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(comment.CommentDeleteResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *CommentDeleteResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *CommentDeleteResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *CommentDeleteResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *CommentDeleteResult) Unmarshal(in []byte) error {
	msg := new(comment.CommentDeleteResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CommentDeleteResult) GetSuccess() *comment.CommentDeleteResp {
	if !p.IsSetSuccess() {
		return CommentDeleteResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CommentDeleteResult) SetSuccess(x interface{}) {
	p.Success = x.(*comment.CommentDeleteResp)
}

func (p *CommentDeleteResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CommentDeleteResult) GetResult() interface{} {
	return p.Success
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) CommentAdd(ctx context.Context, Req *comment.CommentAddReq) (r *comment.CommentAddResp, err error) {
	var _args CommentAddArgs
	_args.Req = Req
	var _result CommentAddResult
	if err = p.c.Call(ctx, "CommentAdd", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CommentList(ctx context.Context, Req *comment.CommentListReq) (r *comment.CommentListResp, err error) {
	var _args CommentListArgs
	_args.Req = Req
	var _result CommentListResult
	if err = p.c.Call(ctx, "CommentList", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CommentUpdate(ctx context.Context, Req *comment.CommentUpdateReq) (r *comment.CommentUpdateResp, err error) {
	var _args CommentUpdateArgs
	_args.Req = Req
	var _result CommentUpdateResult
	if err = p.c.Call(ctx, "CommentUpdate", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CommentDelete(ctx context.Context, Req *comment.CommentDeleteReq) (r *comment.CommentDeleteResp, err error) {
	var _args CommentDeleteArgs
	_args.Req = Req
	var _result CommentDeleteResult
	if err = p.c.Call(ctx, "CommentDelete", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
