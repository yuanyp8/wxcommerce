// Code generated by Kitex v0.9.0. DO NOT EDIT.

package productservice

import (
	"context"
	"errors"
	client "github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	streaming "github.com/cloudwego/kitex/pkg/streaming"
	product "github.com/yuanyp8/wxcommerce/shared/kitex_gen/pms/product"
	proto "google.golang.org/protobuf/proto"
)

var errInvalidMessageType = errors.New("invalid message type for service method handler")

var serviceMethods = map[string]kitex.MethodInfo{
	"ProductAdd": kitex.NewMethodInfo(
		productAddHandler,
		newProductAddArgs,
		newProductAddResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"ProductList": kitex.NewMethodInfo(
		productListHandler,
		newProductListArgs,
		newProductListResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"ProductListByIds": kitex.NewMethodInfo(
		productListByIdsHandler,
		newProductListByIdsArgs,
		newProductListByIdsResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"ProductUpdate": kitex.NewMethodInfo(
		productUpdateHandler,
		newProductUpdateArgs,
		newProductUpdateResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"ProductDelete": kitex.NewMethodInfo(
		productDeleteHandler,
		newProductDeleteArgs,
		newProductDeleteResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"ProductDetailById": kitex.NewMethodInfo(
		productDetailByIdHandler,
		newProductDetailByIdArgs,
		newProductDetailByIdResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
}

var (
	productServiceServiceInfo                = NewServiceInfo()
	productServiceServiceInfoForClient       = NewServiceInfoForClient()
	productServiceServiceInfoForStreamClient = NewServiceInfoForStreamClient()
)

// for server
func serviceInfo() *kitex.ServiceInfo {
	return productServiceServiceInfo
}

// for client
func serviceInfoForStreamClient() *kitex.ServiceInfo {
	return productServiceServiceInfoForStreamClient
}

// for stream client
func serviceInfoForClient() *kitex.ServiceInfo {
	return productServiceServiceInfoForClient
}

// NewServiceInfo creates a new ServiceInfo containing all methods
func NewServiceInfo() *kitex.ServiceInfo {
	return newServiceInfo(false, true, true)
}

// NewServiceInfo creates a new ServiceInfo containing non-streaming methods
func NewServiceInfoForClient() *kitex.ServiceInfo {
	return newServiceInfo(false, false, true)
}
func NewServiceInfoForStreamClient() *kitex.ServiceInfo {
	return newServiceInfo(true, true, false)
}

func newServiceInfo(hasStreaming bool, keepStreamingMethods bool, keepNonStreamingMethods bool) *kitex.ServiceInfo {
	serviceName := "ProductService"
	handlerType := (*product.ProductService)(nil)
	methods := map[string]kitex.MethodInfo{}
	for name, m := range serviceMethods {
		if m.IsStreaming() && !keepStreamingMethods {
			continue
		}
		if !m.IsStreaming() && !keepNonStreamingMethods {
			continue
		}
		methods[name] = m
	}
	extra := map[string]interface{}{
		"PackageName": "pms",
	}
	if hasStreaming {
		extra["streaming"] = hasStreaming
	}
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.9.0",
		Extra:           extra,
	}
	return svcInfo
}

func productAddHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(product.ProductAddReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(product.ProductService).ProductAdd(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *ProductAddArgs:
		success, err := handler.(product.ProductService).ProductAdd(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ProductAddResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newProductAddArgs() interface{} {
	return &ProductAddArgs{}
}

func newProductAddResult() interface{} {
	return &ProductAddResult{}
}

type ProductAddArgs struct {
	Req *product.ProductAddReq
}

func (p *ProductAddArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(product.ProductAddReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *ProductAddArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *ProductAddArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *ProductAddArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *ProductAddArgs) Unmarshal(in []byte) error {
	msg := new(product.ProductAddReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ProductAddArgs_Req_DEFAULT *product.ProductAddReq

func (p *ProductAddArgs) GetReq() *product.ProductAddReq {
	if !p.IsSetReq() {
		return ProductAddArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ProductAddArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ProductAddArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ProductAddResult struct {
	Success *product.ProductAddResp
}

var ProductAddResult_Success_DEFAULT *product.ProductAddResp

func (p *ProductAddResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(product.ProductAddResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *ProductAddResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *ProductAddResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *ProductAddResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *ProductAddResult) Unmarshal(in []byte) error {
	msg := new(product.ProductAddResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ProductAddResult) GetSuccess() *product.ProductAddResp {
	if !p.IsSetSuccess() {
		return ProductAddResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ProductAddResult) SetSuccess(x interface{}) {
	p.Success = x.(*product.ProductAddResp)
}

func (p *ProductAddResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ProductAddResult) GetResult() interface{} {
	return p.Success
}

func productListHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(product.ProductListReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(product.ProductService).ProductList(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *ProductListArgs:
		success, err := handler.(product.ProductService).ProductList(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ProductListResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newProductListArgs() interface{} {
	return &ProductListArgs{}
}

func newProductListResult() interface{} {
	return &ProductListResult{}
}

type ProductListArgs struct {
	Req *product.ProductListReq
}

func (p *ProductListArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(product.ProductListReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *ProductListArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *ProductListArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *ProductListArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *ProductListArgs) Unmarshal(in []byte) error {
	msg := new(product.ProductListReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ProductListArgs_Req_DEFAULT *product.ProductListReq

func (p *ProductListArgs) GetReq() *product.ProductListReq {
	if !p.IsSetReq() {
		return ProductListArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ProductListArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ProductListArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ProductListResult struct {
	Success *product.ProductListResp
}

var ProductListResult_Success_DEFAULT *product.ProductListResp

func (p *ProductListResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(product.ProductListResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *ProductListResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *ProductListResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *ProductListResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *ProductListResult) Unmarshal(in []byte) error {
	msg := new(product.ProductListResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ProductListResult) GetSuccess() *product.ProductListResp {
	if !p.IsSetSuccess() {
		return ProductListResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ProductListResult) SetSuccess(x interface{}) {
	p.Success = x.(*product.ProductListResp)
}

func (p *ProductListResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ProductListResult) GetResult() interface{} {
	return p.Success
}

func productListByIdsHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(product.ProductByIdsReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(product.ProductService).ProductListByIds(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *ProductListByIdsArgs:
		success, err := handler.(product.ProductService).ProductListByIds(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ProductListByIdsResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newProductListByIdsArgs() interface{} {
	return &ProductListByIdsArgs{}
}

func newProductListByIdsResult() interface{} {
	return &ProductListByIdsResult{}
}

type ProductListByIdsArgs struct {
	Req *product.ProductByIdsReq
}

func (p *ProductListByIdsArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(product.ProductByIdsReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *ProductListByIdsArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *ProductListByIdsArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *ProductListByIdsArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *ProductListByIdsArgs) Unmarshal(in []byte) error {
	msg := new(product.ProductByIdsReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ProductListByIdsArgs_Req_DEFAULT *product.ProductByIdsReq

func (p *ProductListByIdsArgs) GetReq() *product.ProductByIdsReq {
	if !p.IsSetReq() {
		return ProductListByIdsArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ProductListByIdsArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ProductListByIdsArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ProductListByIdsResult struct {
	Success *product.ProductListResp
}

var ProductListByIdsResult_Success_DEFAULT *product.ProductListResp

func (p *ProductListByIdsResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(product.ProductListResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *ProductListByIdsResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *ProductListByIdsResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *ProductListByIdsResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *ProductListByIdsResult) Unmarshal(in []byte) error {
	msg := new(product.ProductListResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ProductListByIdsResult) GetSuccess() *product.ProductListResp {
	if !p.IsSetSuccess() {
		return ProductListByIdsResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ProductListByIdsResult) SetSuccess(x interface{}) {
	p.Success = x.(*product.ProductListResp)
}

func (p *ProductListByIdsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ProductListByIdsResult) GetResult() interface{} {
	return p.Success
}

func productUpdateHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(product.ProductUpdateReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(product.ProductService).ProductUpdate(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *ProductUpdateArgs:
		success, err := handler.(product.ProductService).ProductUpdate(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ProductUpdateResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newProductUpdateArgs() interface{} {
	return &ProductUpdateArgs{}
}

func newProductUpdateResult() interface{} {
	return &ProductUpdateResult{}
}

type ProductUpdateArgs struct {
	Req *product.ProductUpdateReq
}

func (p *ProductUpdateArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(product.ProductUpdateReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *ProductUpdateArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *ProductUpdateArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *ProductUpdateArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *ProductUpdateArgs) Unmarshal(in []byte) error {
	msg := new(product.ProductUpdateReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ProductUpdateArgs_Req_DEFAULT *product.ProductUpdateReq

func (p *ProductUpdateArgs) GetReq() *product.ProductUpdateReq {
	if !p.IsSetReq() {
		return ProductUpdateArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ProductUpdateArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ProductUpdateArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ProductUpdateResult struct {
	Success *product.ProductUpdateResp
}

var ProductUpdateResult_Success_DEFAULT *product.ProductUpdateResp

func (p *ProductUpdateResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(product.ProductUpdateResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *ProductUpdateResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *ProductUpdateResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *ProductUpdateResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *ProductUpdateResult) Unmarshal(in []byte) error {
	msg := new(product.ProductUpdateResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ProductUpdateResult) GetSuccess() *product.ProductUpdateResp {
	if !p.IsSetSuccess() {
		return ProductUpdateResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ProductUpdateResult) SetSuccess(x interface{}) {
	p.Success = x.(*product.ProductUpdateResp)
}

func (p *ProductUpdateResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ProductUpdateResult) GetResult() interface{} {
	return p.Success
}

func productDeleteHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(product.ProductDeleteReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(product.ProductService).ProductDelete(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *ProductDeleteArgs:
		success, err := handler.(product.ProductService).ProductDelete(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ProductDeleteResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newProductDeleteArgs() interface{} {
	return &ProductDeleteArgs{}
}

func newProductDeleteResult() interface{} {
	return &ProductDeleteResult{}
}

type ProductDeleteArgs struct {
	Req *product.ProductDeleteReq
}

func (p *ProductDeleteArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(product.ProductDeleteReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *ProductDeleteArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *ProductDeleteArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *ProductDeleteArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *ProductDeleteArgs) Unmarshal(in []byte) error {
	msg := new(product.ProductDeleteReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ProductDeleteArgs_Req_DEFAULT *product.ProductDeleteReq

func (p *ProductDeleteArgs) GetReq() *product.ProductDeleteReq {
	if !p.IsSetReq() {
		return ProductDeleteArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ProductDeleteArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ProductDeleteArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ProductDeleteResult struct {
	Success *product.ProductDeleteResp
}

var ProductDeleteResult_Success_DEFAULT *product.ProductDeleteResp

func (p *ProductDeleteResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(product.ProductDeleteResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *ProductDeleteResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *ProductDeleteResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *ProductDeleteResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *ProductDeleteResult) Unmarshal(in []byte) error {
	msg := new(product.ProductDeleteResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ProductDeleteResult) GetSuccess() *product.ProductDeleteResp {
	if !p.IsSetSuccess() {
		return ProductDeleteResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ProductDeleteResult) SetSuccess(x interface{}) {
	p.Success = x.(*product.ProductDeleteResp)
}

func (p *ProductDeleteResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ProductDeleteResult) GetResult() interface{} {
	return p.Success
}

func productDetailByIdHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(product.ProductDetailByIdReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(product.ProductService).ProductDetailById(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *ProductDetailByIdArgs:
		success, err := handler.(product.ProductService).ProductDetailById(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ProductDetailByIdResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newProductDetailByIdArgs() interface{} {
	return &ProductDetailByIdArgs{}
}

func newProductDetailByIdResult() interface{} {
	return &ProductDetailByIdResult{}
}

type ProductDetailByIdArgs struct {
	Req *product.ProductDetailByIdReq
}

func (p *ProductDetailByIdArgs) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetReq() {
		p.Req = new(product.ProductDetailByIdReq)
	}
	return p.Req.FastRead(buf, _type, number)
}

func (p *ProductDetailByIdArgs) FastWrite(buf []byte) (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.FastWrite(buf)
}

func (p *ProductDetailByIdArgs) Size() (n int) {
	if !p.IsSetReq() {
		return 0
	}
	return p.Req.Size()
}

func (p *ProductDetailByIdArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *ProductDetailByIdArgs) Unmarshal(in []byte) error {
	msg := new(product.ProductDetailByIdReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ProductDetailByIdArgs_Req_DEFAULT *product.ProductDetailByIdReq

func (p *ProductDetailByIdArgs) GetReq() *product.ProductDetailByIdReq {
	if !p.IsSetReq() {
		return ProductDetailByIdArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ProductDetailByIdArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ProductDetailByIdArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ProductDetailByIdResult struct {
	Success *product.ProductDetailByIdResp
}

var ProductDetailByIdResult_Success_DEFAULT *product.ProductDetailByIdResp

func (p *ProductDetailByIdResult) FastRead(buf []byte, _type int8, number int32) (n int, err error) {
	if !p.IsSetSuccess() {
		p.Success = new(product.ProductDetailByIdResp)
	}
	return p.Success.FastRead(buf, _type, number)
}

func (p *ProductDetailByIdResult) FastWrite(buf []byte) (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.FastWrite(buf)
}

func (p *ProductDetailByIdResult) Size() (n int) {
	if !p.IsSetSuccess() {
		return 0
	}
	return p.Success.Size()
}

func (p *ProductDetailByIdResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *ProductDetailByIdResult) Unmarshal(in []byte) error {
	msg := new(product.ProductDetailByIdResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ProductDetailByIdResult) GetSuccess() *product.ProductDetailByIdResp {
	if !p.IsSetSuccess() {
		return ProductDetailByIdResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ProductDetailByIdResult) SetSuccess(x interface{}) {
	p.Success = x.(*product.ProductDetailByIdResp)
}

func (p *ProductDetailByIdResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ProductDetailByIdResult) GetResult() interface{} {
	return p.Success
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) ProductAdd(ctx context.Context, Req *product.ProductAddReq) (r *product.ProductAddResp, err error) {
	var _args ProductAddArgs
	_args.Req = Req
	var _result ProductAddResult
	if err = p.c.Call(ctx, "ProductAdd", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ProductList(ctx context.Context, Req *product.ProductListReq) (r *product.ProductListResp, err error) {
	var _args ProductListArgs
	_args.Req = Req
	var _result ProductListResult
	if err = p.c.Call(ctx, "ProductList", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ProductListByIds(ctx context.Context, Req *product.ProductByIdsReq) (r *product.ProductListResp, err error) {
	var _args ProductListByIdsArgs
	_args.Req = Req
	var _result ProductListByIdsResult
	if err = p.c.Call(ctx, "ProductListByIds", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ProductUpdate(ctx context.Context, Req *product.ProductUpdateReq) (r *product.ProductUpdateResp, err error) {
	var _args ProductUpdateArgs
	_args.Req = Req
	var _result ProductUpdateResult
	if err = p.c.Call(ctx, "ProductUpdate", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ProductDelete(ctx context.Context, Req *product.ProductDeleteReq) (r *product.ProductDeleteResp, err error) {
	var _args ProductDeleteArgs
	_args.Req = Req
	var _result ProductDeleteResult
	if err = p.c.Call(ctx, "ProductDelete", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ProductDetailById(ctx context.Context, Req *product.ProductDetailByIdReq) (r *product.ProductDetailByIdResp, err error) {
	var _args ProductDetailByIdArgs
	_args.Req = Req
	var _result ProductDetailByIdResult
	if err = p.c.Call(ctx, "ProductDetailById", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
